"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.SFIFO = void 0;
/*
*Supports configurable any width and depth
*Supports choosing whether to output 'almost full' and 'almost_empty', which is not output by default.
*Supports adjustable water levels for almost_full and almost_empty. If not configured, the default values for almost_full are maximum depth minus 1 and almost_empty is 1
*Supports two types of SRAMs for FIFO storage: '1rw' and '1r1w', with a default value of '1r1w'.
*Please note that the FIFO read and write enable interfaces generated by these two types are different. When '1rw', rw is high write and low read
*/
var TSSV_1 = require("tssv/lib/core/TSSV");
var SRAM_1 = require("tssv/lib/modules/SRAM");
var SFIFO = /** @class */ (function (_super) {
    __extends(SFIFO, _super);
    function SFIFO(params) {
        var _this = _super.call(this, {
            // define the default parameter values
            name: params.name,
            dataWidth: params.dataWidth,
            depth: params.depth,
            InclAlmostDepth: params.InclAlmostDepth || 'none',
            rw_mode: params.rw_mode || '1r_1w'
        }) || this;
        var almost_full_depth = _this.params.almost_full_depth || (params.depth - 1n);
        var almost_empty_depth = _this.params.almost_empty_depth || 1n;
        // calculate address width based on depth
        var addr_width = _this.bitWidth(_this.params.depth - 1n);
        var addr_width_set = addr_width;
        if (_this.params.depth === 1n) {
            addr_width_set = 1;
        }
        // ============================================IO define start===========================================
        // define IO signals
        _this.IOs = {
            clk: { direction: 'input', isClock: 'posedge' },
            rst_n: { direction: 'input', isReset: 'lowasync' },
            data_in: { direction: 'input', width: _this.params.dataWidth },
            data_out: { direction: 'output', width: _this.params.dataWidth },
            empty: { direction: 'output' },
            full: { direction: 'output' },
            curr_depth: { direction: 'output', width: addr_width_set }
        };
        // IO: rd_en wr_en rw_en rw
        if (_this.params.rw_mode === '1r_1w') {
            _this.IOs.rd_en = { direction: 'input' };
            _this.IOs.wr_en = { direction: 'input' };
        }
        else {
            _this.IOs.rw_en = { direction: 'input' };
            _this.IOs.rw = { direction: 'input' };
        }
        // IO: almost_full almost_empty
        if (_this.params.InclAlmostDepth === 'InclAlmostDepth') {
            if (almost_full_depth <= 0) {
                console.log('Error: In \'InclAlmostDepth\' mode, the FIFO depth must be at least greater than 1');
            }
            else if (almost_full_depth >= _this.params.depth) {
                console.log("Error: almost_full_depth ".concat(almost_full_depth, " cannot be greater than or equal to this fifo's depth ").concat(_this.params.depth));
            }
            if (almost_empty_depth >= _this.params.depth) {
                console.log("Error: almost_full_depth ".concat(almost_empty_depth, " cannot be greater than or equal to this fifo's depth ").concat(_this.params.depth));
            }
            _this.IOs.almost_full = { direction: 'output' };
            _this.IOs.almost_empty = { direction: 'output' };
        }
        // width and depth check
        if (_this.params.dataWidth <= 0)
            console.log('Error: dataWidth should be greater than 0');
        if (_this.params.depth <= 0)
            console.log('Error: Depth should be greater than 0');
        // ===========================================IO define enf==============================================
        // calculate fifo_cnt width
        var fifo_cnt_width = addr_width_set;
        if (_this.params.depth === 1n) {
            fifo_cnt_width = 1;
        }
        else if (Math.log2(Number(_this.params.depth)) % 1 === 0) {
            fifo_cnt_width = addr_width_set + 1;
        }
        // add wr_addr and rd_addr
        _this.addSignal('wr_addr', { width: addr_width_set });
        _this.addSignal('rd_addr', { width: addr_width_set });
        // add temp counter
        _this.addSignal('fifo_cnt', { width: fifo_cnt_width });
        // add sram read and write enable
        _this.addSignal('sram_read_en', {});
        _this.addSignal('sram_write_en', {});
        // Instantce RAM as the storage unit for FIFO
        if (_this.params.rw_mode === '1rw') {
            _this.addSignal('rd_en', {});
            _this.addSignal('wr_en', {});
            _this.addSignal('sram_a_addr', { width: addr_width_set });
            _this.addAssign({ in: new TSSV_1.Expr('rw_en && rw'), out: 'wr_en' }); // 'rw' high write low read
            _this.addAssign({ in: new TSSV_1.Expr('rw_en && ~rw'), out: 'rd_en' });
            _this.addAssign({ in: new TSSV_1.Expr('sram_write_en ? wr_addr : rd_addr'), out: 'sram_a_addr' });
            // instance 1rw
            _this.addSubmodule("u_".concat(_this.params.name, "_sram"), new SRAM_1.SRAM({ name: "".concat(_this.params.name, "_sram"), dataWidth: _this.params.dataWidth, depth: _this.params.depth, ports: '1rw' }), { clk: 'clk', a_re: 'sram_read_en', a_we: 'sram_write_en', a_data_in: 'data_in', a_data_out: 'data_out', a_addr: 'sram_a_addr' });
        }
        else {
            // instance 1r_1w
            _this.addSubmodule("u_".concat(_this.params.name, "_sram"), new SRAM_1.SRAM({ name: "".concat(_this.params.name, "_sram"), dataWidth: _this.params.dataWidth, depth: _this.params.depth, ports: '1r_1w' }), { clk: 'clk', a_re: 'sram_read_en', a_data_out: 'data_out', a_addr: 'rd_addr', b_we: 'sram_write_en', b_data_in: 'data_in', b_addr: 'wr_addr' });
        }
        _this.addAssign({ in: new TSSV_1.Expr("(fifo_cnt == ".concat(fifo_cnt_width, "'d").concat(_this.params.depth, ") ? 1'b1 : 1'b0")), out: 'full' });
        _this.addAssign({ in: new TSSV_1.Expr('~(|fifo_cnt)'), out: 'empty' });
        _this.addAssign({ in: new TSSV_1.Expr('fifo_cnt'), out: 'curr_depth' });
        if (_this.params.InclAlmostDepth === 'InclAlmostDepth') {
            _this.addAssign({ in: new TSSV_1.Expr("(fifo_cnt >= ".concat(almost_full_depth, ") ? 1 : 0")), out: 'almost_full' });
            _this.addAssign({ in: new TSSV_1.Expr("(fifo_cnt <= ".concat(almost_empty_depth, ") ? 1 : 0")), out: 'almost_empty' });
        }
        _this.addAssign({ in: new TSSV_1.Expr('!empty && rd_en'), out: 'sram_read_en' });
        _this.addAssign({ in: new TSSV_1.Expr('!full && wr_en'), out: 'sram_write_en' });
        // fifo read
        var read_body = "\n    // fifo read\n    always_ff @( posedge clk or negedge rst_n ) begin\n        if (!rst_n) begin\n            rd_addr <= ".concat(addr_width_set, "'d0;\n        end\n        else if (sram_read_en) begin\n            if (rd_addr == ").concat(addr_width_set, "'d").concat(_this.params.depth - 1n, ") begin\n                rd_addr <= ").concat(addr_width_set, "'d0;\n            end else begin\n                rd_addr <= rd_addr + ").concat(addr_width_set, "'d1;\n                end\n        end\n    end\n    ");
        _this.addSequentialAlways({ clk: 'clk', reset: 'rst_n', outputs: ['rd_addr', 'data_out'] }, read_body);
        // fifo write
        var write_body = "\n    // fifo write\n    always_ff @( posedge clk or negedge rst_n ) begin\n        if (!rst_n) begin\n            wr_addr <= ".concat(addr_width_set, "'d0;\n        end\n        else if (sram_write_en) begin\n            if (wr_addr == ").concat(addr_width_set, "'d").concat(_this.params.depth - 1n, ") begin\n                wr_addr <= ").concat(addr_width_set, "'d0;\n            end else begin\n                wr_addr <= wr_addr + ").concat(addr_width_set, "'d1;\n            end\n        end\n    end\n    ");
        _this.addSequentialAlways({ clk: 'clk', reset: 'rst_n', outputs: ['wr_addr'] }, write_body);
        // cnt calculate
        var cnt_body = "\n    // Setting FIFO counter value for different situations of read and write operations\n    always_ff @( posedge clk or negedge rst_n ) begin\n        if(!rst_n) begin\n            fifo_cnt <= ".concat(fifo_cnt_width, "'d0;\n        end else if (sram_write_en && sram_read_en) begin\n            fifo_cnt <= fifo_cnt;\n        end else if (sram_write_en) begin\n            fifo_cnt <= fifo_cnt + ").concat(fifo_cnt_width, "'d1;\n        end else if (sram_read_en) begin\n            fifo_cnt <= fifo_cnt - ").concat(fifo_cnt_width, "'d1;\n        end\n    end\n    ");
        if (_this.params.rw_mode === '1rw') {
            cnt_body =
                "\n    // Setting FIFO counter value for different situations of read and write operations\n    always_ff @( posedge clk or negedge rst_n ) begin\n        if(!rst_n) begin\n            fifo_cnt <= ".concat(fifo_cnt_width, "'d0;\n        end else begin\n            if (sram_write_en) begin\n                fifo_cnt <= fifo_cnt + ").concat(fifo_cnt_width, "'d1;\n            end\n            if (sram_read_en) begin\n                fifo_cnt <= fifo_cnt - ").concat(fifo_cnt_width, "'d1;\n            end\n        end\n    end\n    ");
        }
        _this.addSequentialAlways({ clk: 'clk', reset: 'rst_n', outputs: ['fifo_cnt'] }, cnt_body);
        return _this;
    }
    return SFIFO;
}(TSSV_1.Module));
exports.SFIFO = SFIFO;
exports.default = SFIFO;
